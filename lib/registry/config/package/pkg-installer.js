// Generated by LiveScript 1.2.0
(function(){
  var GlobalConfig, gconf, fs, exec, Q, RegistryClient, registry, install, uninstall, PkgInstaller, toString$ = {}.toString, slice$ = [].slice;
  GlobalConfig = require('../../../global-config');
  gconf = new GlobalConfig;
  fs = require('fs-extra');
  exec = require('child_process').exec;
  Q = require('q');
  RegistryClient = require('bower-registry-client');
  registry = new RegistryClient({
    strictSsl: false,
    timeout: 12000
  });
  install = registry.install;
  uninstall = registry.uninstall;
  module.exports = PkgInstaller = (function(){
    PkgInstaller.displayName = 'PkgInstaller';
    var prototype = PkgInstaller.prototype, constructor = PkgInstaller;
    function PkgInstaller(type, names){
      this.type = type;
      this.names = names;
      this.validate();
      this;
    }
    prototype.validate = function(){
      if (toString$.call(this.type).slice(8, -1) !== 'String') {
        throw Error("Type must be a String, was: " + this.type);
      }
      if (toString$.call(this.names).slice(8, -1) !== 'Array') {
        throw Error("Names must be an Array, was: " + this.names);
      }
    };
    prototype.install = function(){
      var deferred, command, this$ = this;
      deferred = Q.defer();
      command = this[this.type + "Install"]();
      if (!command) {
        return deferred.promise;
      }
      exec(command, deferred.makeNodeResolver());
      return deferred.promise.then(function(stdout){
        return true;
      })['catch'](function(error){
        console.error(error);
        throw error;
      });
    };
    prototype.uninstall = function(){
      var names, deferred, toUninstall, command, this$ = this;
      names = slice$.call(arguments);
      deferred = Q.defer();
      toUninstall = names.filter(function(name){
        return this$.isInstalledPkg(name);
      });
      if (!(toUninstall.length > 1)) {
        return deferred.promise;
      }
      command = this[this.type + "Uninstall"](toUninstall);
      if (!command) {
        return deferred.promise;
      }
      exec(command, deferred.makeNodeResolver());
      return deferred.promise.then(function(stdout){
        return true;
      })['catch'](function(error){
        console.error(error);
        throw error;
      });
    };
    prototype.bowerInstall = function(){
      if (this.uninstalled().length < 1) {
        return;
      }
      return "bower install " + this.uninstalledArgs() + " --save-dev";
    };
    prototype.bowerUninstall = function(names){
      if (typeof names === 'string') {
        names = [names];
      }
      names = names.join(' ');
      return "bower uninstall " + names;
    };
    prototype.componentInstall = function(){};
    prototype.uninstalledArgs = function(){
      return this.uninstalled().join(' ');
    };
    prototype.uninstalled = function(){
      var this$ = this;
      return this._uninstalled || (this._uninstalled = this.names.filter(function(name){
        return this$.installed().indexOf(name) === -1;
      }));
    };
    prototype.installed = function(){
      var this$ = this;
      return this._installed || (this._installed = this.names.filter(function(name){
        return this$.isInstalledPkg(name);
      }));
    };
    prototype.isInstalledPkg = function(name){
      var e;
      name = this.pkgName(name);
      try {
        return fs.statSync(this.pkgDir(name)).isDirectory();
      } catch (e$) {
        e = e$;
        return false;
      }
    };
    prototype.pkgName = function(name){
      var repo, shortRepo;
      repo = name.match(/git:\/\/github.com\/(.*)\.git/);
      if (repo) {
        name = repo[1];
      }
      shortRepo = name.match(/\/(.*)$/);
      if (shortRepo) {
        return shortRepo[1];
      }
      return name;
    };
    prototype.pkgDir = function(name){
      return [this.containerDir(), name].join('/');
    };
    prototype.containerDir = function(){
      return gconf.dirFor(this.type);
    };
    return PkgInstaller;
  }());
}).call(this);
