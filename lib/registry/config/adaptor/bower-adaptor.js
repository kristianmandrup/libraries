// Generated by LiveScript 1.2.0
(function(){
  var FileIO, RegistryClient, registry, search, syncRequest, retrieve, fs, util, jsonlint, Q, isBlank, escapeRegExp, GithubRepoTranslator, logx, BowerAdapter, toString$ = {}.toString, slice$ = [].slice;
  FileIO = require('../../../file-io');
  RegistryClient = require('bower-registry-client');
  registry = new RegistryClient({
    strictSsl: false,
    timeout: 12000
  });
  search = registry.lookup;
  syncRequest = require('sync-request');
  retrieve = require('../../../remote').retrieve;
  fs = require('fs-extra');
  util = require('util');
  jsonlint = require('jsonlint');
  Q = require('q');
  isBlank = function(str){
    return !str || /^\s*$/.test(str);
  };
  escapeRegExp = function(str){
    return str.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  };
  GithubRepoTranslator = require('./bower/github-repo-translator');
  logx = function(msg){
    return console.log(util.inspect(msg));
  };
  module.exports = BowerAdapter = (function(){
    BowerAdapter.displayName = 'BowerAdapter';
    var prototype = BowerAdapter.prototype, constructor = BowerAdapter;
    importAll$(prototype, arguments[0]);
    function BowerAdapter(name, options){
      this.name = name;
      this.options = options != null
        ? options
        : {};
      this.validate();
      if (this.options.repo) {
        this.repos.push(this.options.repo);
      }
      this;
    }
    prototype.validate = function(){
      if (toString$.call(this.name).slice(8, -1) !== 'String') {
        throw new Error("Name of bower component must be a String, was: " + util.inspect(this.name));
      }
    };
    prototype.adapt = function(){
      return {
        main: this.main(),
        files: slice$.call(this.files, 1, -1 + 1 || 9e9)
      };
    };
    prototype.main = function(){
      return this.files()[0];
    };
    prototype.files = function(){
      if (this.hasMain()) {
        return this.mainFiles();
      } else {
        return [];
      }
    };
    prototype.hasMain = function(){
      return this.mainFiles().then(function(files){
        return files && files.length > 0;
      });
    };
    prototype.mainFiles = function(){
      return this.bowerJson().then(function(json){
        return json.main;
      });
    };
    prototype.bowerJson = function(){
      return this.bower || (this.bower = this.retrieve().then(function(body){
        return jsonlint.parse(body);
      }));
    };
    prototype.retrieve = function(){
      var this$ = this;
      return this.repoUri().then(function(uri){
        return this$.retrieveBody(uri);
      });
    };
    prototype.retrieveBody = function(uri){
      var deferred, this$ = this;
      deferred = Q.defer();
      retrieve(uri, deferred.makeNodeResolver());
      return deferred.promise.then(function(body){
        return body;
      });
    };
    prototype.retrieveSync = function(){
      var this$ = this;
      return this.repoUri().then(function(uri){
        return this$.retrieved || (this$.retrieved = syncRequest('GET', uri).getBody());
      });
    };
    prototype.repoTranslator = function(repo){
      return new GithubRepoTranslator(repo);
    };
    prototype.repoUri = function(){
      var this$ = this;
      return this.repo().then(function(repo){
        this$._repo = repo;
        return this$.repoTranslator(repo).translate();
      });
    };
    prototype.repos = [];
    prototype.repo = function(){
      return this.findRepos(function(repos){
        if (repos.length === 0) {
          return this.repos[0];
        } else {
          return repos[0];
        }
      });
    };
    prototype.filtered = function(){
      var this$ = this;
      return this._filtered || (this._filtered = this.foundRepos.filter(function(repo){
        var name;
        name = escapeRegExp(this$.name);
        return repo.match(new RegExp(name + ".git$"));
      }));
    };
    prototype.findRepos = function(cb){
      var this$ = this;
      return this.find().promise.then(function(foundRepos){
        this$.foundRepos = this$.map(foundRepos);
        return cb(this$.filtered());
      });
    };
    prototype.map = function(repos){
      var this$ = this;
      switch (toString$.call(repos).slice(8, -1)) {
      case 'Object':
        return [repos.url];
      case 'Array':
        return repos.map(function(repo){
          return this$.map(repo);
        });
      }
    };
    prototype.find = function(){
      var deferred;
      deferred = Q.defer();
      registry.lookup(this.name, deferred.makeNodeResolver());
      return deferred;
    };
    return BowerAdapter;
  }(FileIO));
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
