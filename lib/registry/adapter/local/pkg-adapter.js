// Generated by LiveScript 1.2.0
(function(){
  var FileIO, Installer, BaseAdapter, fs, util, jsonlint, Q, isBlank, syncRequest, retrieve, GlobalConfig, gconf, RegistryPackageAdapter, toString$ = {}.toString;
  FileIO = require('../../../util/file-io');
  Installer = require('../../config/installer');
  BaseAdapter = require('../base-adapter');
  fs = require('fs-extra');
  util = require('util');
  jsonlint = require('jsonlint');
  Q = require('q');
  isBlank = function(str){
    return !str || /^\s*$/.test(str);
  };
  syncRequest = require('sync-request');
  retrieve = require('../../../util/remote').retrieve;
  GlobalConfig = require('../../../global-config');
  gconf = new GlobalConfig;
  module.exports = RegistryPackageAdapter = (function(superclass){
    var prototype = extend$((import$(RegistryPackageAdapter, superclass).displayName = 'RegistryPackageAdapter', RegistryPackageAdapter), superclass).prototype, constructor = RegistryPackageAdapter;
    importAll$(prototype, arguments[1]);
    function RegistryPackageAdapter(options){
      this.options = options != null
        ? options
        : {};
      this.type || (this.type = 'bower');
      this.pkgName = this.options.pkgName || 'libraries';
      this.installerType = this.options.installer || 'json';
      this.pkgPath = gconf.dirFor(this.type);
      RegistryPackageAdapter.superclass.apply(this, arguments);
    }
    prototype.validate = function(){
      if (toString$.call(this.pkgPath).slice(8, -1) !== 'String') {
        throw new Error("pkg path must be a String, was:");
      }
    };
    prototype.installer = function(type){
      type || (type = this.installerType);
      return this._installer || (this._installer = new Installer(type));
    };
    prototype.install = function(name){
      return this.installer().install({
        source: this.readConfig(name),
        target: this.targetConfig(name)
      });
    };
    prototype.readConfig = function(name){
      return this.index()[name];
    };
    prototype.registryLibsUri = function(){
      return this.registryLocationParts().join('/');
    };
    prototype.registryLocationParts = function(){
      return [this.pkgPath, this.pkgName, this.registriesPath(), this.libsFile()].filter(function(part){
        return !!part;
      });
    };
    prototype.registriesPath = function(){
      return 'registry';
    };
    prototype.libsFile = function(){
      return this.type + "-libs.json";
    };
    prototype.indexContent = function(options){
      options == null && (options = {});
      return this._indexContent || (this._indexContent = this.retrieve().then(function(body){
        return body;
      }));
    };
    prototype.retrieve = function(){
      return this.retrieveBody(this.registryLibsUri());
    };
    prototype.retrieveBody = function(uri){
      var deferred, this$ = this;
      deferred = Q.defer();
      fs.readFile(uri, 'utf-8', deferred.makeNodeResolver());
      return deferred.promise.then(function(body){
        return body;
      });
    };
    prototype.index = function(){
      return this.indexContent().then(function(body){
        return jsonlint.parse(body);
      });
    };
    prototype.list = function(){
      return this._list || (this._list = this.index().then(function(obj){
        return Object.keys(obj);
      }));
    };
    return RegistryPackageAdapter;
  }(BaseAdapter, FileIO));
  function extend$(sub, sup){
    function fun(){} fun.prototype = (sub.superclass = sup).prototype;
    (sub.prototype = new fun).constructor = sub;
    if (typeof sup.extended == 'function') sup.extended(sub);
    return sub;
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function importAll$(obj, src){
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}).call(this);
